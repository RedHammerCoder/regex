# Regex
## 介绍
使用C++实现正则表达式引擎   
作为词法分析器的前置工具
## 功能
1. 根据输入的正则表达式规则建立DFA 或者 NFA 实现对逻辑的 图化
2. 根据需要匹配的项目进行匹配输出

## 设计要点
1. 正则关键词 
    - 关键词怎么影响流程图
    - DFA 和 NFA的转化
2. 正则表达式对多种字符的支持
3. 算法效率的优化
4. 算法实现的要点
    - 结点与子节点分层 使用层级简化回退操作
5. 使用NFA作为正则表达式的初次初始化结果

## 正则表达式语法
1. 
    - \f 
    - \n 
    - \r /s /S /t /v
    - $匹配字符串的结尾位置
    - ()匹配一个子表达式
    - *前一个字符零个或者多个
    - +前一个字符一个或者多个
    - .代替任意字符一个
    - []中括号表达式
    - ?匹配前一个子表达式一个或者0个  并且表示非贪婪限定符
    - \下一个字符作为标记字符或者特殊字符
    - ^匹配输入字符串的开始位置
    - {}
        - {n} 上一个子串限定匹配n次
        - {5,m}上一个子串限定匹配至少5次 至多m次
    - | 两项之间的选择

### 定位符
\b 匹配一个单词边界
\B 非单词边界匹配


## Tech_log 
### 结点处理模式 
1. divide 结点处理
    -  '|' 如果上一个结点是div结点则将下一个节点插入到div节点中
        - 如果上一个结点不是div结点 则生成一个div结点并且将上一个结点以及下一个结点作为div结点的子结点
        - div结点将被设置为当前父结点的tail结点
    - 

2. （）小括号结点 bracket 结点
    - 构成 ： （父结点 子结点 指针） （在节点内存在一条链条，.next 
    - 只有bucket 结点可以为父结点 
    - 遇到‘（’则建立一个新的结点 当前父结点为新节点的父结点 当前节点的tail设置为新生成的结点
    - 遇到‘）’则将本结点提升一层
3. {*?+} 符号的特殊处理 
    - 输入这三个符号会导致控制流发生改变 需要做好准备
    - 使用标志位而不使用指针有利于简化流程的控制 避免了多个指针的需求


## NFA2DFA


## example
reg = (()|([a-z]|(regix)*))